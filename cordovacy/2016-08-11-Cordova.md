---
layout: post
title: Mobile applications with Cytoscape.js and Cordova
subtitle: Using Cytoscape.js to create a web of Wikipedia links
tags:
- tutorial
---

# Introduction

This post is the final part of a series of Cytoscape.js tutorials written by [Joseph Stahl](josephstahl.com) for Google Summer of Code 2016.
For previous tutorials, see:

- [Tutorial 1: Getting Started]({% post_url 2016-05-24-getting-started %})
- [Tutorial 2: Glycolysis]({% post_url 2016-06-08-glycolysis %})
- [Tutorial 3: Twitter Social Network]({% post_url 2016-07-04-social-network %})
- [Tutorial 4: Cytoscape.js desktop application with Electron]({% post_url 2016-07-24-cytoscape-electron %})

In this tutorial, we'll be using [Cordova](PUT LINK HERE) and [Cytoscape.js](js.cytoscape.org) to create a mobile app which can create a graph of Wikipedia pages, with each page a node and links between pages as edges.

# Setup

## Cordova

First, we'll need to install Cordova globally with `npm install cordova@6.3 -g`.
Using version 6.3 ensures compatibility with this tutorial.
Now that Cordova is installed, we can use it to take care of creating the directory for our app.

*Note: it's best to provide your own reverse domain name here because signing applications for testing on iOS requires a unique RDN*.
Run `cordova create cordovacy com.madeUpReverseDomain.cordovacy cordovacy` to create a new directory called `cordovacy`, containing an application named `cordovacy` and the provided reverse-domain-name.
With this done, `cd` into the new directory.

## package.json

As before, we'll use [npm](PUT LINK HERE) to install parts of our application.
However, we'll only be using npm for Cordova this time; the rest of the application will use a separate package manager, [Bower](PUT LINK HERE), to manage dependencies and take a setup out of building the application each time—we won't have to run [Browserify](PUT LINK HERE).
Create a `package.json` file (`npm init` can automate this) and the following dependencies:

```json
{
  "name": "cordova-cy",
  "version": "0.1.0",
  "description": "",
  "main": "echo \"cordova app\"",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "cordova run browser"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "bower": "^1.7.9",
    "cordova": "^6.3.0"
  }
}
```

You may wish to install Bower globally to make calling it easier—you'll be able to use `$ bower` instead of `$ node_modules/.bin/bower`.
If you choose to not to install Bower and Cordova globally, prefix any later commands I use with `node_modules/bin`.
Run `npm install` to install Bower.

## bower.json

Now that Bower is installed, we can install the front-end files—CSS and JavaScript—that our application will depend on.
Similar to `package.json`, create a `bower.json` file by running `bower init` and answering the questions.
Once this is done, we'll install the necessary files, saving them as we go: `bower install cytoscape skeleton font-awesome jquery#2.2.4 cytoscape-qtip qtip2#2.2.1 --save`.

By default, Bower will place downloaded files in `bower_components/` so to add them to the project, we'll need to copy them to Cordova's `www/` directory (created during `cordova create`).

Copy the following files from their various folders in `bower_components/`, placing them in the proper location inside `www/` (`js` for JavaScript files; `css` for style sheets): 

```
+-- js/
  +-- cytoscape.js
  +-- cytoscape-qtip.js
  +-- jquery.js
  +-- jquery.qtip.min.js
+-- css/
  +-- font-awesome.css
  +-- jquery.qtip.min.css
  +-- normalize.css
  +-- skeleton.css
+-- fonts/
  +-- FontAwesome.otf
  +-- fontawesome-webfont.* (all fontawesome-webfont files)
```

# Cordova preparation

We'll need to modify the default files generated by `cordova create` before we can use them.
Most of these changes are related to us not using a framework such as Angular.js; because of this, many files can be simplified.

## config.xml

We'll have to modify `config.xml` slightly, primarily to update app variables (such as name and developer) but also to change app behavior slightly.
Because we're writing our app as a webpage, mobile platforms may default to "bouncing" the web page if scrolled around, which is undesirable for an app that is supposed to act native.
To fix this, insert `<preference name="DisallowOverscroll" value="true" />` immediately above the last line of the file (so that it's within the `<widget>` block).
While the file's open, modify the description and author properties as you see fit.

## index.html

We'll make many more changes to `index.html` later but for now, just insert the following line at the beginning of `<head>`:

```html
  <meta http-equiv="Content-Security-Policy" content="default-src * blob:; style-src 'self' 'unsafe-inline'; script-src 'self' https://*.wikipedia.org 'unsafe-inline' 'unsafe-eval'">
```

This is **not** a safe Content Security Policy for a published application (notice how it loads almost anything) but is suitable for a demonstration application where ease-of-development is important.
Note the inclusion of *.wikipedia.org as a script source; we'll be using [JSONP](PUT LINK HERE) for issuing API requests; running the JavaScript returned by Wikipedia requires us to list it as a safe source.

## Platforms

By default, Cordova does not give us any platforms (iOS, Android, etc.) to run our application on.
This application will focus on developing for Android and iOS but we'll also include a third platform, browser, which will make testing and debugging general app behavior much easier (of course, testing on emulators and actual devices is still highly recommended after obvious bugs are eliminated!).
To add these platforms, run `cordova platform add android ios browser --save`.
This will download the necessary files for each platform and allow you to later use commands like `cordova run browser` for testing.
I am using version 4.1.0 of the browser platform, 5.2.1 of the android platform, and VERSION OF IOS PLATFORM.
Because Android and iOS both change API versions frequently, it may be necessary to run, for example, `cordova platform add android@5.2.1` to ensure compatibility with this tutorial.

# Big changes to index.html

## head

Now that we've made Cordova's security policy more permissive, we'll move on to adding our own code.
Modify `<head>` to look like the following:

```html
<head>
    <!-- This policy allows everything (eg CSS, AJAX, object, frame, media, etc) except that 
      * CSS only from the same origin and inline styles,
      * scripts only from the same origin and inline styles, and eval(). And wikipedia, for JSONP
    -->
  <meta http-equiv="Content-Security-Policy" content="default-src * blob:; style-src 'self' 'unsafe-inline'; script-src 'self' https://*.wikipedia.org 'unsafe-inline' 'unsafe-eval'">

  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">
  <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
  <link rel="stylesheet" type="text/css" href="css/normalize.css">
  <link rel="stylesheet" type="text/css" href="css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="css/jquery.qtip.min.css">
  <link rel="stylesheet" type="text/css" href="css/index.css">
  <title>Wikipedia Graph</title>
</head>
```

In addition to the previously mentioned security policy, you can see that we've updated the title and added a number of our own CSS files.

## body

We'll be making so many changes to `<body>` that it's probably easiest to delete all existing code and start from scratch.

```html
<body>
  <div id="deviceready">
    <div class="event listening">
      <i class="fa fa-refresh fa-spin"></i>
    </div>
  </div>
  <div class="container">
    <!-- input area -->
    <h1>Tutorial 5</h1>
    <div class="row">
      <input type="text" class="u-full-width" id="pageTitle" placeholder="Wikipedia starting page">
    </div>
    <div class="row">
      <div class="six columns">
        <input type="button" class="button-primary u-full-width" id="submitButton" value="Start graph" type="submit">
      </div>
      <div class="six columns">
        <input type="button" class="button-primary u-full-width" id="redoLayoutButton" value="Redo layout" type="submit">
      </div>
    </div>
    <!-- graph area -->
    <div id="cy"></div>
  </div>

  <script type="text/javascript" src="js/jquery.js"></script>
  <script type="text/javascript" src="js/cytoscape.js"></script>
  <script type="text/javascript" src="js/jquery.qtip.min.js"></script>
  <script type="text/javascript" src="js/cytoscape-qtip.js"></script>
  <script type="text/javascript" src="js/graph.js"></script>
  <script type="text/javascript" src="cordova.js"></script>
  <script type="text/javascript" src="js/index.js"></script>
</body>
```

You may recognize the various classes (such as `container`, `row`, and `columns`) from [Tutorial 4]({% post_url 2016-07-24-cytoscape-electron %}); in fact, we're reusing a lot of that code because the UI is very similar—an input field and two buttons.
Likewise, we're reusing the Font Awesome loading spinner from previous tutorials.
This time it's in the `deviceready` section and will appear while the application is loading.
As always, we're using a `<div id="cy">` element for holding the graph.

Unlike before, scripts are now at the very end of `<body>`, saving us from using a `DOMContentLoaded` listener. 
`cordova.js` and `js/index.js` are necessary for Cordova to function; the remaining files are our own and relate to Cytoscape.js.

# Small changes to index.js

Within the `js/` folder, there's a file named `index.js` that Cordova created for us.
We'll change it some; because we aren't using any device plugins (GPS, orientation, etc.) we don't have to wait for a `deviceready` event.
If you compare `index.html` to the original `index.html` that Cordova created for us, you'll notice that there is no longer any element with the `received` class.
Therefore, we'll remove the associated code from the `receivedEvent` function in `index.js`:

```javascript
  receivedEvent: function(id) {
    var parentElement = document.getElementById(id);
    var listeningElement = parentElement.querySelector('.listening');

    listeningElement.setAttribute('style', 'display:none;');

    console.log('Received Event: ' + id);
  }
```

The code for our `listening` class is still present as we are using it for showing the Font Awesome loading icon during application loading and hiding it when loading has finished.
The rest of `index.js` is unchanged.

# index.css

We need to make a number of changes to `index.css` to bring it in line with the many modifications we made to `index.html`, as well as to make sure our graph has room.
Delete the old code and replace it with the following:

```css
html, body {
  height: 100%;
}

#deviceready {
  height: 100%;
  width: 100%;
}

.container {
    display: flex;
    flex-flow: column;
    height: 100%;
}

#deviceready {
  position: absolute;
  left: 0;
  top: 50%;
  width: 100%;
  text-align: center;
  margin-top: -0.5em;
  font-size: 2em;
  color: #fff;
}

#cy {
    flex: 1 1 auto;
}
```

The common theme here is: use as much space as possible.
We can't rely on automatic `height` properties here because we want our graph to take up as much space as possible.
If we allowed the height to be determined automatically, we'd end up with a 0px tall graph because the `<div id="cy">` element does not take up any space by default.
We'll use the same [flexbox](PUT LINK HERE) based layout from [Tutorial 4]({% post_url 2016-07-24-cytoscape-electron %}) to help us with filling the phone screen here.

# graph.js

Now that we've finished getting Cordova prepared and `index.html` ready for the graph, it's time to move on to the heart of the application: the graph.

## Initialization

Add the following code to `graph.js` (in the `js/` folder): 

```javascript
var apiPath = 'https://en.wikipedia.org/w/api.php';

var cy = window.cy = cytoscape({
  container: document.getElementById('cy'),
  style: [
    {
      selector: 'node',
      style: {
        'label': 'data(id)'
      }
    }
  ]
});
```

We're starting out simple, first with `apiPath`, which holds the URL of the [MediaWiki API](PUT LINK HERE) that powers this tutorial.
Next, we'll initialize `cy` by using the `cy` container and modifying the default style slightly to show node IDs as labels.

## The API

Here the benefits of using Wikipedia's API (which requires no authentication) becomes apparent; we can send off requests without ever having to worry about API keys and secrets.
Also, we only to make a single request to get the information necessary for the graph instead of having to make separate user and followers calls as in Tutorials 3 and 4.

```javascript
var createRequest = function(pageTitle) {
  var settings = {
    'url': apiPath,
    'jsonp': 'callback',
    'dataType': 'jsonp',
    'data': {
      'action': 'query',
      'titles': pageTitle,
      'prop': 'links',
      'format': 'json'
    },
    'xhrFields': { 'withCredentials': true },
    'headers': { 'Api-User-Agent': 'Cytoscape.js-Tutorial/0.1 (https://github.com/cytoscape/cytoscape.js-tutorials; putyour@email.here)' }
  };

  return $.ajax(settings);
};
```

Note that we're only *creating* the request, not actually sending it yet.
We'll write a function later that sends the request and adds the returned data to the graph.

`apiPath`, defined earlier, is used here for the URL of the API to be accessed while the specifics of the request are put in the `data` object.
[Look at the MediaWiki API description](PUT LINK HERE) for information about other properties that can be queried, and other API requests besides query that can be made.

jQuery will handle the specifics of creating our API request; for example, our data is a JavaScript object but jQuery will convert that to part of a GET request.
It's important to note the line with `'jsonp': 'callback'`; this tells Wikipedia that we're sending a special type of request ([JSONP](PUT LINK HERE)) which gets around the [Same Origin Policy](PUT LINK HERE).

## parseData()

Next in `graph.js` is `parseData(response)`, which will convert the data returned from Wikipedia into an array of objects that can be added to Cytoscape.js.

```javascript
var parseData = function(response) {
  var results = [];
  function makeEdges(sourcePage, links) {
    return links.map(function(link) {
      return {
        data: {
          id: 'edge-' + sourcePage + '-' + link.title,
          source: sourcePage,
          target: link.title
        }
      };
    });
  }

  for (var key in response.query.pages) {
    if ({}.hasOwnProperty.call(response.query.pages, key)) {
      var page = response.query.pages[key];

      // source page (the page with the links on it)
      results.push({
        data: {
          id: page.title
        }
      });

      // nodes
      // see note on apply https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push
      var links = page.links;
      try {
        Array.prototype.push.apply(results, links.map(function(link) {
          return {
            data: {
              id: link.title
            }
          };
        }));

        // edges
        Array.prototype.push.apply(results, makeEdges(page.title, page.links));
      } catch (error) {
        console.log('error adding pages. API request failed?');
      }
    }
  }
  return results;
};
```

As we work through the returned data, first creating an object for the source page (which may not yet be present in the graph if the graph is newly created), then linked pages, then linkks as edges, we'll add the objects to the `results` array.
This type of work—basically rearranging values in an array—is ideally suited to the [`map()`](PUT LINK HERE) function.

Before we can start, we'll define a function for creating links which is little more than a wrapper around `.map()` to make sure that the name of the "source" page is available.
The following code makes more sense if I first outline the format of the JSON returned from Wikipedia, so I'll do that now:

```json
  "continue": {
    "plcontinue": "736|0|Action-angle_variables",
    "continue": "||"
  },
  "query": {
    "pages": {
      "736": {
        "pageid": 736,
        "ns": 0,
        "title": "Albert Einstein",
        "links": [
          {
            "ns": 0,
            "title": "2dF Galaxy Redshift Survey"
          },
          {
            "ns": 0,
            "title": "A priori and a posteriori"
          }
        ]
      }
    }
  }
}
```

*many more links excluded for brevity*

The `continue` object is used if we're querying successive pages of the graph; doing so is more complicated and would make the graph quickly unwieldy on mobile devices so we can ignore that section.
Next, we have the results of the query in the `query` object.
For our query type, we'll only get a single page returned (accessed by its `pageid`; in this case, 736).
The pageid will be different for each page and we can't simply access `pages[0]` because this is not an array, which leaves us iterating over the keys of the `pages` object.

```javascript
for (var key in response.query.pages) {
    if ({}.hasOwnProperty.call(response.query.pages, key)) {
      var page = response.query.pages[key];
```

*link to page about why I'm using {}.hasOwnProperty*
This is slightly more complex than a foreach loop in other languages because JavaScript will default to giving us not only the keys of this object (in this case, response.query.pages), but also the keys of any prototypes of the object.
To account for this, we'll wrap our code within a check for `{}.hasOwnProperty.call(response.query.pages, key)`. 

With this check completed, we can start adding data to `results`.
First, we'll add the source page to make sure that edges have a source node.
Because `results` is currently empty, we can add to the array using [`.push()`](PUT LINK HERE).

```javascript
      results.push({
        data: {
          id: page.title
        }
      });
```

Next, we'll add the links and edges within a `try/catch` block to ensure that API errors don't trip up our application.

```javascript
      var links = page.links;
      try {
        Array.prototype.push.apply(results, links.map(function(link) {
          return {
            data: {
              id: link.title
            }
          };
        }));

        // edges
        Array.prototype.push.apply(results, makeEdges(page.title, page.links));
      } catch (error) {
        console.log('error adding pages. API request failed?');
      }
    }
```

As mentioned above, `.map()` is ideal for this kind of work on nodes. We'll take an object `{ "ns": 0, "title": "linkedPageTitle" }` and convert it to a [Cytoscape.js element](PUT LINK HERE) in the form { data: { id: 'linkedPageTitle } }.
We'll add the mapped array to `results` via [`push()`](PUT LINK HERE); however, we'll need to also use [`apply()`](PUT LINK HERE) because `push()` expects a list of arguments rather than a single array.
In other words, we're going from `push([foo, bar])` to `push(foo, bar)`.

A similar thing is done for the edges, except that we'll use our helper function `makeEdges()` to ensure that `map()` can access the title of the page (which is used as the source of the edge).
A final call to `return results` finishes this function!
With this, we can consider the API work to be done; we've converted everything into objects Cytoscape.js can use so we don't need to worry about how the API returns data from this point onwards.

 



